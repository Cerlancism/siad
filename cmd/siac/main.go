package main

import (
	"encoding/json"
	"fmt"
	"log"
	"os"
	"runtime"
	"strings"
	"text/tabwriter"

	"go.sia.tech/core/types"
	"go.sia.tech/siad/v2/api"
	"lukechampine.com/flagg"
)

var (
	// to be supplied at build time
	githash   = "?"
	builddate = "?"
)

var (
	rootUsage = `Usage:
    siac [flags] [action|subcommand]

Actions:
    version         display version information

Subcommands:
    wallet          manage the wallet
    txpool          manage the txpool
    syncer          manage the syncer
    host            manage the host
    renter          manage the renter
    miner           manage the miner
`
	versionUsage = rootUsage

	walletUsage = `Usage:
    siac [flags] wallet [flags] [action]

Actions:
    balance         display current balance
    address         display wallet address
    addresses       display all addresses generated by the wallet
    transactions    display transactions relevant to the wallet
    sign            sign a JSON encoded transaction
`

	walletBalanceUsage = `Usage:
siac [flags] wallet [flags] balance

Displays the current wallet balance in siacoins.
`
	walletAddressUsage = `Usage:
siac [flags] wallet [flags] address

Displays an address controlled by the wallet.
`
	walletAddressesUsage = `Usage:
siac [flags] wallet [flags] addresses

Displays all addresses generated by the wallet.
`

	walletTransactionsUsage = `Usage:
siac [flags] wallet [flags] transactions

Displays all transactions relevant to the wallet, ordered oldest-to-newest.
`

	walletSignUsage = `Usage:
siac [flags] wallet [flags] sign [txn] [element IDs]

Signs a JSON encoded transaction.  If a JSON encoded list of element IDs is provided, those inputs will
be signed.  If no list of element IDs is provided, all inputs will be signed.
`

	txpoolUsage = `Usage:
    siac [flags] txpool [flags] [action]

Actions:
    transactions    display all transactions in the transaction pool
    broadcast       broadcast a JSON encoded transaction
`

	txpoolBroadcastUsage = `Usage:
siac [flags] txpool [flags] broadcast [txn]

Broadcast a JSON encoded transaction.
`

	txpoolTransactionsUsage = `Usage:
siac [flags] txpool [flags] transactions

Displays all transactions in the transaction pool
`

	syncerUsage = `Usage:
    siac [flags] syncer [flags] [action]

Actions:
	peers           display all the syncer's peers
	addresss        display the syncer's listening address
	connect         add a peer to the syncer
`

	syncerPeersUsage = `Usage:
siac [flags] syncer [flags] peers

List all the syncer's peers.
`

	syncerAddressUsage = `Usage:
siac [flags] syncer [flags] address

Display the syncer's listening address.
`

	syncerConnectUsage = `Usage:
siac [flags] syncer [flags] connect [addr]

Adds the provided address as a peer of the syncer.
`
)

func check(ctx string, err error) {
	if err != nil {
		log.Fatalln(ctx, err)
	}
}

var siadAddr string

func getClient() *api.Client {
	if !strings.HasPrefix(siadAddr, "https://") && !strings.HasPrefix(siadAddr, "http://") {
		siadAddr = "http://" + siadAddr
	}
	c := api.NewClient(siadAddr)
	_, err := c.WalletBalance()
	check("couldn't connect to siad:", err)
	return c
}

func makeTabWriter() *tabwriter.Writer {
	return tabwriter.NewWriter(
		os.Stdout,
		0,   // minwidth: zero, since we're left-aligning
		0,   // tabwidth: zero, since we're using ' ',  not '\t'
		2,   // padding:  two, so that columns aren't right next to each other
		' ', // padchar:  spaces, not tabs
		0,   // flags:    none
	)
}

func readTxn(filename string) types.Transaction {
	js, err := os.ReadFile(filename)
	check("Could not read transaction file", err)
	var txn types.Transaction
	err = json.Unmarshal(js, &txn)
	check("Could not parse transaction file", err)
	return txn
}

func main() {
	log.SetFlags(0)

	rootCmd := flagg.Root
	rootCmd.Usage = flagg.SimpleUsage(rootCmd, rootUsage)
	rootCmd.StringVar(&siadAddr, "a", "localhost:9980", "siad API server address")
	verbose := rootCmd.Bool("v", false, "print verbose output")

	versionCmd := flagg.New("version", versionUsage)

	walletCmd := flagg.New("wallet", walletUsage)
	walletBalanceCmd := flagg.New("balance", walletBalanceUsage)
	exactBalance := walletBalanceCmd.Bool("exact", false, "print balance in Hastings")
	walletAddressCmd := flagg.New("address", walletAddressUsage)
	walletAddressesCmd := flagg.New("addresses", walletAddressesUsage)
	walletTransactionsCmd := flagg.New("transactions", walletTransactionsUsage)
	walletSignCmd := flagg.New("sign", walletSignUsage)

	txpoolCmd := flagg.New("txpool", txpoolUsage)
	txpoolBroadcastCmd := flagg.New("broadcast", txpoolBroadcastUsage)
	txpoolTransactionsCmd := flagg.New("transactions", txpoolTransactionsUsage)

	syncerCmd := flagg.New("syncer", syncerUsage)
	syncerPeersCmd := flagg.New("peers", syncerPeersUsage)
	syncerAddressCmd := flagg.New("address", syncerAddressUsage)
	syncerConnectCmd := flagg.New("connect", syncerConnectUsage)

	_, _ = verbose, exactBalance

	cmd := flagg.Parse(flagg.Tree{
		Cmd: rootCmd,
		Sub: []flagg.Tree{
			{Cmd: versionCmd},
			{
				Cmd: walletCmd,
				Sub: []flagg.Tree{
					{Cmd: walletBalanceCmd},
					{Cmd: walletAddressCmd},
					{Cmd: walletAddressesCmd},
					{Cmd: walletTransactionsCmd},
					{Cmd: walletSignCmd},
				},
			},
			{
				Cmd: txpoolCmd,
				Sub: []flagg.Tree{
					{Cmd: txpoolBroadcastCmd},
					{Cmd: txpoolTransactionsCmd},
				},
			},
			{
				Cmd: syncerCmd,
				Sub: []flagg.Tree{
					{Cmd: syncerPeersCmd},
					{Cmd: syncerAddressCmd},
					{Cmd: syncerConnectCmd},
				},
			},
		},
	})
	args := cmd.Args()

	switch cmd {
	case rootCmd:
		if len(args) != 0 {
			cmd.Usage()
			return
		}
		fallthrough
	case versionCmd:
		log.Printf("siac v2.0.0\nCommit:     %s\nGo version: %s %s/%s\nBuild Date: %s\n",
			githash, runtime.Version(), runtime.GOOS, runtime.GOARCH, builddate)

	case walletCmd:
		cmd.Usage()

	case walletBalanceCmd:
		if len(args) != 0 {
			cmd.Usage()
			return
		}
		balance, err := getClient().WalletBalance()
		check("couldn't get balance:", err)
		if *exactBalance {
			fmt.Printf("%d H\n", balance.Siacoins)
		} else {
			fmt.Printf("%s SC\n", balance.Siacoins)
		}

	case walletAddressCmd:
		if len(args) != 0 {
			cmd.Usage()
			return
		}
		address, err := getClient().WalletAddress()
		check("couldn't get address:", err)
		fmt.Println(address.Address)

	case walletAddressesCmd:
		if len(args) != 0 {
			cmd.Usage()
			return
		}
		addresses, err := getClient().WalletAddresses()
		check("couldn't get address:", err)
		for _, address := range addresses {
			fmt.Println(address)
		}

	case walletTransactionsCmd:
		if len(args) != 0 {
			cmd.Usage()
			return
		}
		transactions, err := getClient().WalletTransactions()
		check("couldn't get transactions:", err)

		w := makeTabWriter()
		defer w.Flush()

		fmt.Fprintf(w, "%v\t%v\t%v\t%v\n", "Index", "ID", "Inflow", "Outflow")
		for _, txn := range transactions {
			fmt.Fprintf(w, "%v\t%v\t%v\t%v\n", txn.Index, txn.ID, txn.Inflow, txn.Outflow)
		}

	case walletSignCmd:
		if len(args) == 0 {
			cmd.Usage()
			return
		}

		txn := readTxn(args[0])
		var toSign []types.ElementID
		if len(args) > 1 {
			file, err := os.Open(args[1])
			check("failed to open JSON file:", err)
			check("failed to decode JSON:", json.NewDecoder(file).Decode(&toSign))
		}
		signed, err := getClient().WalletSign(txn, toSign)
		check("failed to sign transaction:", err)
		encoded, err := json.Marshal(signed.Transaction)
		check("failed to marshal signed transaction:", err)
		fmt.Println(string(encoded))

	case txpoolCmd:
		cmd.Usage()

	case txpoolBroadcastCmd:
		if len(args) != 1 {
			cmd.Usage()
			return
		}

		txn := readTxn(args[0])
		check("failed to broadcast transaction:", getClient().WalletBroadcastTransaction(txn))
		fmt.Println("Announced transaction")

	case txpoolTransactionsCmd:
		if len(args) != 0 {
			cmd.Usage()
			return
		}

		transactions, err := getClient().TxpoolTransactions()
		check("couldn't get transactions:", err)
		for _, txn := range transactions {
			fmt.Println(txn)
		}

	case syncerCmd:
		cmd.Usage()

	case syncerPeersCmd:
		if len(args) != 0 {
			cmd.Usage()
			return
		}
		peers, err := getClient().SyncerPeers()
		check("couldn't get peers:", err)
		for _, peer := range peers {
			fmt.Println(peer.NetAddress)
		}

	case syncerAddressCmd:
		if len(args) != 0 {
			cmd.Usage()
			return
		}
		addr, err := getClient().SyncerAddress()
		check("couldn't get address:", err)
		fmt.Println(addr.Address)

	case syncerConnectCmd:
		if len(args) != 1 {
			cmd.Usage()
			return
		}
		addr := args[0]
		check("couldn't connect:", getClient().SyncerConnect(addr))
		fmt.Printf("Syncer connected to %s\n", addr)

	}
}
